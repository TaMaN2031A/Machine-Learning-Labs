---
title: "PCA And Sequence Alignment"
author: "Abdullah Taman"
date: "2024-03-09"
output: github_document
---

```{r}
library(tidyverse)
library(rentrez)
library(seqinr)
library(Biostrings)
library(ggplot2)
library("FactoMineR")
library(ggcorrplot)
library('corrr')

```
# Part One
----------
First performing the PCA
```{r}
cancer <- read.csv("J:/champions work/datasets/BrainCancerMin.csv", header = TRUE)
?princomp()
```
Now we'll perform the PCA
I faced an issue with the code, This error: 
Error in princomp.default(remove_type, cor = TRUE, scores = TRUE) : 
  'princomp' can only be used with more units than variables


```{r}
remove_type <- subset(cancer, select = c(3:ncol(cancer)))
data_normalized <- scale(remove_type)
corr_matrix <- cor(data_normalized)
ggcorrplot(corr_matrix)
data.pca <- princomp(as.data.frame(corr_matrix))
#summary(data.pca)
```

```{r}
# Extract principal component scores
pc_scores <- data.pca$scores

# Plot Comp.1 vs Comp.2
plot(pc_scores[,1], pc_scores[,2], xlab = "Component 1", ylab = "Component 2", 
     main = "Comp.1 vs Comp.2")

# Plot Comp.1 vs Comp.3
plot(pc_scores[,1], pc_scores[,3], xlab = "Component 1", ylab = "Component 3", 
     main = "Comp.1 vs Comp.3")

# Plot Comp.2 vs Comp.3
plot(pc_scores[,2], pc_scores[,3], xlab = "Component 2", ylab = "Component 3", 
     main = "Comp.2 vs Comp.3")

```
Component 1 vs Component 2 is the best, why ? You could see that the number of points that are overlapped is the least number in it.
```{r}
# Extract eigenvalues
eigenvalues <- data.pca$sdev^2

# Create data frame for plotting
scree_data <- data.frame(Component = 1:length(eigenvalues), Eigenvalue = eigenvalues)

# Plot scree plot
ggplot(scree_data, aes(x = Component, y = Eigenvalue)) +
  geom_point() +
  geom_line() +
  scale_x_continuous(breaks = seq(1, 20, by = 1)) +  # Adjust x-axis breaks for better readability
  labs(x = "Principal Component", y = "Eigenvalue", title = "Scree Plot for First 20 Principal Components")

```
In multivariate statistics, a scree plot is a line plot of the eigenvalues of factors or principal components in an analysis.[1] The scree plot is used to determine the number of factors to retain in an exploratory factor analysis (FA) or principal components to keep in a principal component analysis (PCA).
We could see that starting from the 6th eigen value the eigen values are so small that they don't affect anything in the results.

# Part Two
----------
```{r}
diab <- read.csv("J:/champions work/datasets/diabetes_prediction_dataset.csv")
```
```{r}
allele1 <- substr(diab$alleles, 1, 1)  # First character of alleles
allele2 <- substr(diab$alleles, 2, 2)  # Second character of alleles

allele_counts <- table(No_Diabetes = c(allele1, allele2), Diabetes = rep(diab$diabetes, 2))

# Convert table to data frame for easier manipulation
allele_counts_df <- as.data.frame(allele_counts)

# Print the resulting table
print(allele_counts_df)

```

```{r}
allele_counts <- matrix(c(91660, 8499, 91340, 8501), ncol = 2, byrow = TRUE)

# Perform Fisher's exact test
fisher_result <- fisher.test(allele_counts)

# Extract p-value
p_value <- fisher_result$p.value

# Report the p-value
print(p_value)
```
It's not significant at all, .81 is very big. Which means that the association is not significant.
```{r}
# Extract BMI samples for each allele family
BMI_AA <- subset(diab, alleles == "AA")$bmi
BMI_AC <- subset(diab, alleles == "AC")$bmi
BMI_CC <- subset(diab, alleles == "CC")$bmi

# Perform t-test between BMI samples for AA and AC allele families
t_test_AA_AC <- t.test(BMI_AA, BMI_AC)

# Perform t-test between BMI samples for AA and CC allele families
t_test_AA_CC <- t.test(BMI_AA, BMI_CC)

# Perform t-test between BMI samples for AC and CC allele families
t_test_AC_CC <- t.test(BMI_AC, BMI_CC)

# Report p-values
p_value_AA_AC <- t_test_AA_AC$p.value
p_value_AA_CC <- t_test_AA_CC$p.value
p_value_AC_CC <- t_test_AC_CC$p.value

# Print p-values
print(p_value_AA_AC)
print(p_value_AA_CC)
print(p_value_AC_CC)

```
It's clear that there is no real significant difference between the family of alleles when it's related to BMI phenotype.
```
```
# Part Three
------------
There are two mismatches.

![](C:/Users/20106/Pictures/Screenshots/d.png)
![](C:/Users/20106/Pictures/Screenshots/a.png)
![](C:/Users/20106/Pictures/Screenshots/b.png)
![](C:/Users/20106/Pictures/Screenshots/c.png)

```{r}
seq1 <- entrez_fetch(db = "nucleotide", id = "NG_050578.1", rettype = "fasta")
seq2 <- entrez_fetch(db = "nucleotide", id = "X03562.1", rettype = "fasta")
seq1

```
```{r}
seq1_lines <- unlist(strsplit(seq1, "\n"))
seq1_lines <- seq1_lines[!grepl(">", seq1_lines)]
seq1_clean <- paste(seq1_lines, collapse = "")

seq2_lines <- unlist(strsplit(seq2, "\n"))
seq2_lines <- seq2_lines[!grepl(">", seq2_lines)]
seq2_clean <- paste(seq2_lines, collapse = "")

seq1 <- DNAStringSet(seq1_clean)
seq2 <- DNAStringSet(seq2_clean)

print(seq1)
print(seq2)
```
```{r}
freq_seq1 <- alphabetFrequency(seq1)
freq_seq2 <- alphabetFrequency(seq2)
print(freq_seq1)
print(freq_seq2)
seq1_has_gaps_ambiguous <- any(names(freq_seq1) %in% c("-", "N")) 
seq2_has_gaps_ambiguous <- any(names(freq_seq2) %in% c("-", "N")) 
print(seq1_has_gaps_ambiguous)
print(seq2_has_gaps_ambiguous)
```
this means that the two sequences are clean
```{r}
seq1_has_gaps_ambiguous <- any(grepl("[-N]", seq1))
seq2_has_gaps_ambiguous <- any(grepl("[-N]", seq2))

# 2. Remove gaps and ambiguous bases from sequences
seq1_cleaned <- gsub("[-N]", "", seq1)
seq2_cleaned <- gsub("[-N]", "", seq2)
seq1_length_before <- nchar(seq1)
seq2_length_before <- nchar(seq2)
seq1_length_after <- nchar(seq1_cleaned)
seq2_length_after <- nchar(seq2_cleaned)
print(paste("Sequence 1 length before cleaning:", seq1_length_before))
print(paste("Sequence 2 length before cleaning:", seq2_length_before))
print(paste("Sequence 1 length after cleaning:", seq1_length_after))
print(paste("Sequence 2 length after cleaning:", seq2_length_after))
```
For confirmation, now we're 100% percent that they were clean. We'll work with the seq1, seq2.

```{r}
run_pairwise_alignment <- function(seq1, seq2) {
  # Run Pairwise Local Alignment
  alignment <- pairwiseAlignment(seq1, seq2, substitutionMatrix = "BLOSUM62", gapOpening = -10, gapExtension = -1)

  # Extract alignment score
  alignment_score <- score(alignment)
  
  # Calculate width of each sequence before and after alignment
  seq1_width_before <- nchar(seq1)
  seq2_width_before <- nchar(seq2)
  seq1_width_after <- nchar(pattern(alignment))
  seq2_width_after <- nchar(subject(alignment))
  
  # Return results
  return(list(
    alignment_score = alignment_score,
    seq1_width_before = seq1_width_before,
    seq2_width_before = seq2_width_before,
    seq1_width_after = seq1_width_after,
    seq2_width_after = seq2_width_after,
    alignment = alignment
  ))
}
```


```{r}
alignment_result <- run_pairwise_alignment(seq1, seq2)
```
```{r}
# Report results
print("Alignment Score:")
print(alignment_result$alignment_score)

print("Width of Sequences Before Alignment:")
print(paste("Sequence 1:", alignment_result$seq1_width_before))
print(paste("Sequence 2:", alignment_result$seq2_width_before))

print("Width of Sequences After Alignment:")
print(paste("Sequence 1:", alignment_result$seq1_width_after))
print(paste("Sequence 2:", alignment_result$seq2_width_after))
print(nmismatch(alignment_result$alignment))
print(mismatchTable(alignment_result$alignment))
```

